# Shim.ps1 - Unified shim system for strap v3.1
# Creates dual-file shims (.ps1 + .cmd) for venv/node/simple commands

#region Command Parsing

function Parse-ShimCommandLine {
    param([Parameter(Mandatory)][string]$CommandLine)

    $trimmed = $CommandLine.Trim()

    # JSON array form
    if ($trimmed.StartsWith('[')) {
        $parts = $null
        try {
            $parts = $trimmed | ConvertFrom-Json
        } catch {
            Die "Invalid JSON array: $CommandLine"
        }
        if ($parts.Count -eq 0) {
            Die "Empty command array"
        }
        return @{
            exe = $parts[0]
            baseArgs = @($parts | Select-Object -Skip 1)
        }
    }

    # PowerShell tokenizer
    $tokens = $null
    $errors = $null
    [void][System.Management.Automation.Language.Parser]::ParseInput(
        "& $trimmed",
        [ref]$tokens,
        [ref]$errors
    )

    # Block shell operators
    $blocked = $tokens | Where-Object {
        $_.Kind -in @('Pipe', 'Semi', 'Redirection', 'AndAnd', 'OrOr')
    }
    if ($blocked) {
        Die "Shims only support direct exec + args. Use a wrapper script instead."
    }

    # Extract argument tokens (skip '&' and 'EndOfInput')
    $parts = @($tokens |
        Where-Object { $_.Kind -notin @('Ampersand', 'EndOfInput') } |
        ForEach-Object {
            # For quoted strings, use Value. For everything else, use Text
            if ($_.Value) { $_.Value } else { $_.Text }
        })

    if ($parts.Count -eq 0) {
        Die "Could not parse command: $CommandLine"
    }

    return @{
        exe = $parts[0]
        baseArgs = @($parts | Select-Object -Skip 1)
    }
}

#endregion

#region Template Generation

function Format-ShimBaseArgs {
    param([array]$BaseArgs)

    if (-not $BaseArgs -or $BaseArgs.Count -eq 0) {
        return '@()'
    }

    $quoted = $BaseArgs | ForEach-Object { "`"$($_ -replace '\\', '\\' -replace '"', '`"')`"" }
    return "@($($quoted -join ', '))"
}

function New-ShimPs1Content {
    param([Parameter(Mandatory)][hashtable]$Meta)

    $header = @"
# Generated by strap shim - do not edit
# Repo: $($Meta.repo) | Type: $($Meta.type)$(if ($Meta.venv) { " | Venv: $($Meta.venv)" })$(if ($Meta.cwd) { " | Cwd: $($Meta.cwd)" })
`$ErrorActionPreference = "Stop"
"@

    $baseArgsStr = Format-ShimBaseArgs $Meta.baseArgs

    if ($Meta.cwd) {
        $body = @"
`$ec = 0
Push-Location "$($Meta.cwd)"
try {
$(if ($Meta.venv) { "    `$venv = `"$($Meta.venv)`"`n" })    `$exe = "$($Meta.exe)"
    `$baseArgs = $baseArgsStr
    & `$exe @baseArgs @args
    `$ec = if (`$null -eq `$LASTEXITCODE) { 0 } else { `$LASTEXITCODE }
} finally {
    Pop-Location
}
exit `$ec
"@
    } else {
        $body = @"
$(if ($Meta.venv) { "`$venv = `"$($Meta.venv)`"`n" })`$exe = "$($Meta.exe)"
`$baseArgs = $baseArgsStr
& `$exe @baseArgs @args
`$ec = if (`$null -eq `$LASTEXITCODE) { 0 } else { `$LASTEXITCODE }
exit `$ec
"@
    }

    return "$header`n$body"
}

function New-ShimCmdContent {
    param(
        [Parameter(Mandatory)][string]$ShimName,
        [Parameter(Mandatory)][string]$PwshExe
    )

    return @"
@echo off
"$PwshExe" -NoLogo -NoProfile -ExecutionPolicy Bypass -File "%~dp0$ShimName.ps1" %*
exit /b %errorlevel%
"@
}

#endregion

#region Main Function

function Invoke-Shim {
    param(
        [Parameter(Mandatory)][string]$ShimName,

        # Command specification
        [string]$Cmd,
        [string]$Exe,
        [string[]]$BaseArgs,

        # Shim configuration
        [ValidateSet("simple", "venv", "node")]
        [string]$ShimType = "simple",
        [string]$VenvPath,
        [string]$NodeExe,
        [string]$WorkingDir,

        # Context
        [Parameter(Mandatory)][string]$RegistryEntryName,
        [Parameter(Mandatory)][object]$Config,
        [Parameter(Mandatory)][array]$Registry,

        # Behavior
        [switch]$ForceOverwrite,
        [switch]$DryRun,
        [switch]$AllowMissingVenv
    )

    # Validate shim name
    if ($ShimName -notmatch '^[a-zA-Z0-9_-]+$') {
        Die "Invalid shim name '$ShimName'. Use only alphanumeric, hyphen, underscore."
    }

    # Validate pwshExe exists
    if (-not (Test-Path $Config.defaults.pwshExe)) {
        Die "pwshExe not found: $($Config.defaults.pwshExe). Update strap config."
    }

    # Find repo entry
    $repoEntry = $Registry | Where-Object { $_.name -eq $RegistryEntryName }
    if (-not $repoEntry) {
        Die "Registry entry '$RegistryEntryName' not found."
    }

    # Auto-detect repo context when --repo is specified
    if ($RegistryEntryName) {
        # Auto-set working directory to repo path if not explicitly provided
        if (-not $WorkingDir) {
            $WorkingDir = $repoEntry.path
            Write-Host "  Auto-detected working directory: $WorkingDir" -ForegroundColor Cyan
        }

        # Auto-detect venv for Python repos
        if (-not $VenvPath -and $repoEntry.stack -eq "python") {
            $candidates = @(".venv", "venv", ".virtualenv")
            foreach ($candidate in $candidates) {
                $testPath = Join-Path $repoEntry.path $candidate
                $pythonExe = Join-Path $testPath "Scripts\python.exe"
                if (Test-Path $pythonExe) {
                    $VenvPath = $testPath
                    Write-Host "  Auto-detected venv: $VenvPath" -ForegroundColor Cyan
                    break
                }
            }
        }

        # Auto-determine shim type if not explicitly set
        if ($ShimType -eq "simple") {
            # If we found a venv and the command involves Python, use venv type
            if ($VenvPath -and ($Cmd -match '\bpython\b' -or $Exe -match '\bpython\b')) {
                $ShimType = "venv"
                Write-Host "  Auto-detected shim type: venv" -ForegroundColor Cyan
            }
        }
    }

    # Parse command
    if ($Cmd -and $Exe) {
        Die "Cannot use --cmd with --exe. Pick one."
    }
    if (-not $Cmd -and -not $Exe) {
        Die "Must provide --cmd or --exe."
    }

    if ($Cmd) {
        $parsed = Parse-ShimCommandLine $Cmd
        $shimExe = $parsed.exe
        $shimBaseArgs = $parsed.baseArgs
    } else {
        $shimExe = $Exe
        $shimBaseArgs = if ($BaseArgs) { $BaseArgs } else { @() }
    }

    # Resolve exe based on type
    $resolvedExe = $shimExe
    $resolvedVenv = $null

    switch ($ShimType) {
        "venv" {
            $resolvedVenv = Resolve-ShimVenvPath -RepoPath $repoEntry.path -ExplicitPath $VenvPath -AllowMissing:$AllowMissingVenv
            $resolution = Resolve-ShimVenvExe -Exe $shimExe -VenvPath $resolvedVenv
            $resolvedExe = $resolution.resolvedPath
            if (-not $resolution.exists) {
                if ($AllowMissingVenv) {
                    # Silent for auto-discovery - shim will work after setup
                } else {
                    Warn "Exe not found in venv: $resolvedExe. Shim may not work until package is installed."
                }
            }
        }
        "node" {
            $resolvedExe = Resolve-ShimNodeExe -CliOverride $NodeExe -Config $Config
            # For node type, shimExe becomes baseArgs[0] (JS entrypoint)
            $shimBaseArgs = @($shimExe) + $shimBaseArgs
        }
    }

    # Check for collision
    $shimsDir = $Config.roots.shims
    $ps1Path = Join-Path $shimsDir "$ShimName.ps1"
    $cmdPath = Join-Path $shimsDir "$ShimName.cmd"

    $existingOwner = $null
    foreach ($entry in $Registry) {
        $ownsShim = $entry.shims | Where-Object { $_.name -eq $ShimName }
        if ($ownsShim) {
            $existingOwner = $entry.name
            break
        }
    }

    if ((Test-Path $ps1Path) -or $existingOwner) {
        if ($existingOwner -and $existingOwner -ne $RegistryEntryName) {
            if (-not $ForceOverwrite) {
                Die "Shim '$ShimName' already exists (owned by '$existingOwner'). Use --force to overwrite."
            }
        }
        # Same repo or --force: allow update
    }

    # Build shim metadata
    $shimMeta = @{
        name = $ShimName
        repo = $RegistryEntryName
        type = $ShimType
        exe = $resolvedExe
        baseArgs = $shimBaseArgs
        venv = $resolvedVenv
        cwd = $WorkingDir
    }

    # Generate content
    $ps1Content = New-ShimPs1Content $shimMeta
    $cmdContent = New-ShimCmdContent -ShimName $ShimName -PwshExe $Config.defaults.pwshExe

    if ($DryRun) {
        Write-Host "DRY RUN - no changes will be made" -ForegroundColor Yellow
        Write-Host ""
        Write-Host "Would create:" -ForegroundColor Cyan
        Write-Host "  $ps1Path"
        Write-Host "  $cmdPath"
        Write-Host ""
        Write-Host "Generated .ps1 content:" -ForegroundColor Cyan
        Write-Host "---"
        Write-Host $ps1Content
        Write-Host "---"
        return $null
    }

    # Ensure shims directory exists
    if (-not (Test-Path $shimsDir)) {
        New-Item -ItemType Directory -Path $shimsDir -Force | Out-Null
    }

    # Write files (with rollback on failure)
    try {
        [System.IO.File]::WriteAllText($ps1Path, $ps1Content, (New-Object System.Text.UTF8Encoding($false)))
        [System.IO.File]::WriteAllText($cmdPath, $cmdContent, (New-Object System.Text.UTF8Encoding($false)))
    } catch {
        # Rollback
        if (Test-Path $ps1Path) { Remove-Item $ps1Path -Force }
        if (Test-Path $cmdPath) { Remove-Item $cmdPath -Force }
        Die "Failed to write shim files: $_"
    }

    # Build registry entry
    $shimEntry = @{
        name = $ShimName
        ps1Path = $ps1Path
        type = $ShimType
        exe = $resolvedExe
        baseArgs = $shimBaseArgs
    }
    if ($resolvedVenv) { $shimEntry.venv = $resolvedVenv }
    if ($WorkingDir) { $shimEntry.cwd = $WorkingDir }

    Write-Host "[OK] Created shim: $ShimName" -ForegroundColor Green
    Write-Host "  $ps1Path" -ForegroundColor Gray
    Write-Host "  $cmdPath" -ForegroundColor Gray
    Write-Host "  Registered to: $RegistryEntryName ($ShimType)" -ForegroundColor Gray

    return $shimEntry
}

#endregion

#region Regen Command

function Invoke-ShimRegen {
    param(
        [Parameter(Mandatory)][string]$RepoName,
        [Parameter(Mandatory)][object]$Config,
        [Parameter(Mandatory)][array]$Registry
    )

    $repoEntry = $Registry | Where-Object { $_.name -eq $RepoName }
    if (-not $repoEntry) {
        Die "Registry entry '$RepoName' not found."
    }

    $shims = $repoEntry.shims
    if (-not $shims -or $shims.Count -eq 0) {
        Write-Host "No shims registered for '$RepoName'." -ForegroundColor Yellow
        return
    }

    Write-Host "Regenerating $($shims.Count) shim(s) for '$RepoName'..." -ForegroundColor Cyan

    foreach ($shim in $shims) {
        $shimMeta = @{
            name = $shim.name
            repo = $RepoName
            type = $shim.type
            exe = $shim.exe
            baseArgs = if ($shim.baseArgs) { $shim.baseArgs } else { @() }
            venv = $shim.venv
            cwd = $shim.cwd
        }

        $ps1Content = New-ShimPs1Content $shimMeta
        $cmdContent = New-ShimCmdContent -ShimName $shim.name -PwshExe $Config.defaults.pwshExe

        $shimsDir = $Config.roots.shims
        $ps1Path = Join-Path $shimsDir "$($shim.name).ps1"
        $cmdPath = Join-Path $shimsDir "$($shim.name).cmd"

        [System.IO.File]::WriteAllText($ps1Path, $ps1Content, (New-Object System.Text.UTF8Encoding($false)))
        [System.IO.File]::WriteAllText($cmdPath, $cmdContent, (New-Object System.Text.UTF8Encoding($false)))

        Write-Host "  [OK] $($shim.name)" -ForegroundColor Green
    }

    Write-Host "Done." -ForegroundColor Cyan
}

#endregion

#region Exe Resolution

function Resolve-ShimVenvPath {
    param(
        [Parameter(Mandatory)][string]$RepoPath,
        [string]$ExplicitPath,
        [switch]$AllowMissing
    )

    if ($ExplicitPath) {
        return $ExplicitPath
    }

    $candidates = @(".venv", "venv", ".virtualenv")
    foreach ($candidate in $candidates) {
        $testPath = Join-Path $RepoPath $candidate
        $pythonExe = Join-Path $testPath "Scripts\python.exe"
        if (Test-Path $pythonExe) {
            return $testPath
        }
    }

    # If AllowMissing, return default .venv path even if it doesn't exist
    if ($AllowMissing) {
        return (Join-Path $RepoPath ".venv")
    }

    Die "No venv found in $RepoPath. Use --venv <path> to specify explicitly."
}

function Resolve-ShimVenvExe {
    param(
        [Parameter(Mandatory)][string]$Exe,
        [Parameter(Mandatory)][string]$VenvPath
    )

    $scriptsDir = Join-Path $VenvPath "Scripts"

    # If exe is already an absolute path, use it as-is
    if ([System.IO.Path]::IsPathRooted($Exe)) {
        $resolved = $Exe
    }
    # If exe is just "python", resolve to venv's python.exe
    elseif ($Exe -eq "python") {
        $resolved = Join-Path $scriptsDir "python.exe"
    }
    # If exe already has .exe extension, just prepend Scripts dir
    elseif ($Exe -match '\.exe$') {
        $resolved = Join-Path $scriptsDir $Exe
    }
    # Otherwise, assume it's a bare executable name
    else {
        $resolved = Join-Path $scriptsDir "$Exe.exe"
    }

    return @{
        resolvedPath = $resolved
        exists = Test-Path $resolved
    }
}

function Resolve-ShimNodeExe {
    param(
        [string]$CliOverride,
        [Parameter(Mandatory)][object]$Config
    )

    if ($CliOverride) {
        if (-not (Test-Path $CliOverride)) {
            Die "Node exe not found: $CliOverride"
        }
        return $CliOverride
    }

    if ($Config.defaults.nodeExe -and (Test-Path $Config.defaults.nodeExe)) {
        return $Config.defaults.nodeExe
    }

    $found = Get-Command node -ErrorAction SilentlyContinue
    if ($found) {
        Warn "Using node from PATH: $($found.Source). Consider setting defaults.nodeExe."
        return $found.Source
    }

    Die "Node not found. Set defaults.nodeExe in config or provide --node-exe."
}

#endregion

#region Auto-Discovery

function Invoke-ShimAutoDiscover {
    <#
    .SYNOPSIS
        Automatically discovers and creates shims based on repo stack type.
    .DESCRIPTION
        Scans repo for executable entry points based on detected stack:
        - Python: parses pyproject.toml and setup.py for console_scripts
        - Node: parses package.json bin field
        Creates appropriate shim types (venv for Python, node for Node).
    .PARAMETER RepoEntry
        Registry entry for the repo.
    .PARAMETER Config
        Strap configuration object.
    .PARAMETER Registry
        Full registry array.
    .OUTPUTS
        Array of created shim entries.
    #>
    param(
        [Parameter(Mandatory)][object]$RepoEntry,
        [Parameter(Mandatory)][object]$Config,
        [Parameter(Mandatory)][array]$Registry
    )

    $repoPath = $RepoEntry.path
    $stack = $RepoEntry.stack
    $discovered = @()

    switch ($stack) {
        "python" {
            $discovered = Discover-PythonShims -RepoPath $repoPath
        }
        "node" {
            $discovered = Discover-NodeShims -RepoPath $repoPath
        }
        default {
            # No auto-discovery for other stacks yet
            return @()
        }
    }

    if ($discovered.Count -eq 0) {
        return @()
    }

    Write-Host "  Auto-discovered $($discovered.Count) shim(s) for $stack stack" -ForegroundColor Cyan

    $createdShims = @()
    foreach ($spec in $discovered) {
        try {
            $shimArgs = @{
                ShimName = $spec.name
                Config = $Config
                Registry = $Registry
                RegistryEntryName = $RepoEntry.name
                ShimType = $spec.type
                AllowMissingVenv = $true
            }

            if ($spec.exe) { $shimArgs.Exe = $spec.exe }
            if ($spec.baseArgs) { $shimArgs.BaseArgs = $spec.baseArgs }
            if ($spec.venvPath) { $shimArgs.VenvPath = $spec.venvPath }
            if ($spec.cwd) { $shimArgs.WorkingDir = $spec.cwd }

            $shimEntry = Invoke-Shim @shimArgs
            if ($shimEntry) {
                $createdShims += $shimEntry
            }
        } catch {
            Warn "Failed to create auto-discovered shim '$($spec.name)': $_"
        }
    }

    return $createdShims
}

function Discover-PythonShims {
    param([Parameter(Mandatory)][string]$RepoPath)

    $shims = @()

    # Try pyproject.toml first
    $pyprojectPath = Join-Path $RepoPath "pyproject.toml"
    if (Test-Path $pyprojectPath) {
        $content = Get-Content -LiteralPath $pyprojectPath -Raw

        # Parse [project.scripts] section
        if ($content -match '(?ms)\[project\.scripts\]\s*\n(.*?)(?=\n\[|\z)') {
            $scriptsSection = $matches[1]
            $scriptsSection -split "`n" | ForEach-Object {
                $line = $_.Trim()
                if ($line -and $line -match '^([a-zA-Z0-9_-]+)\s*=') {
                    $shimName = $matches[1]
                    $shims += @{
                        name = $shimName
                        type = "venv"
                        exe = $shimName
                    }
                }
            }
        }

        # Parse [tool.poetry.scripts] section
        if ($content -match '(?ms)\[tool\.poetry\.scripts\]\s*\n(.*?)(?=\n\[|\z)') {
            $scriptsSection = $matches[1]
            $scriptsSection -split "`n" | ForEach-Object {
                $line = $_.Trim()
                if ($line -and $line -match '^([a-zA-Z0-9_-]+)\s*=') {
                    $shimName = $matches[1]
                    if (-not ($shims | Where-Object { $_.name -eq $shimName })) {
                        $shims += @{
                            name = $shimName
                            type = "venv"
                            exe = $shimName
                        }
                    }
                }
            }
        }
    }

    # Try setup.py if no pyproject.toml or no scripts found
    if ($shims.Count -eq 0) {
        $setupPath = Join-Path $RepoPath "setup.py"
        if (Test-Path $setupPath) {
            $content = Get-Content -LiteralPath $setupPath -Raw

            # Simple regex parsing for console_scripts (not perfect but works for common cases)
            if ($content -match '(?ms)console_scripts.*?=.*?\[(.*?)\]') {
                $scriptsBlock = $matches[1]
                $scriptsBlock -split ',' | ForEach-Object {
                    if ($_ -match "[`'`"]\s*([a-zA-Z0-9_-]+)\s*=") {
                        $shimName = $matches[1].Trim()
                        $shims += @{
                            name = $shimName
                            type = "venv"
                            exe = $shimName
                        }
                    }
                }
            }
        }
    }

    return $shims
}

function Discover-NodeShims {
    param([Parameter(Mandatory)][string]$RepoPath)

    $shims = @()
    $packageJsonPath = Join-Path $RepoPath "package.json"

    if (-not (Test-Path $packageJsonPath)) {
        return @()
    }

    try {
        $packageJson = Get-Content -LiteralPath $packageJsonPath -Raw | ConvertFrom-Json

        if ($packageJson.bin) {
            if ($packageJson.bin -is [string]) {
                # Single bin: use package name as shim name
                $shimName = $packageJson.name -replace '^@.*?/', ''
                $shims += @{
                    name = $shimName
                    type = "node"
                    exe = $packageJson.bin
                }
            } elseif ($packageJson.bin -is [PSCustomObject]) {
                # Multiple bins: create shim for each
                $packageJson.bin.PSObject.Properties | ForEach-Object {
                    $shims += @{
                        name = $_.Name
                        type = "node"
                        exe = $_.Value
                    }
                }
            }
        }
    } catch {
        Warn "Failed to parse package.json: $_"
    }

    return $shims
}

#endregion
