### Task 5: Invoke-Adopt - Chinvex Integration

**Files:**
- Modify: `strap.ps1` (modify `Invoke-Adopt` function)
- Test: `tests/powershell/ChinvexAdopt.Tests.ps1` (new)

**Step 1: Write the failing test**
```powershell
# tests/powershell/ChinvexAdopt.Tests.ps1
Describe "Invoke-Adopt Chinvex Integration" -Tag "Task5" {
    BeforeAll {
        # Extract functions from strap.ps1
        $strapContent = Get-Content "$PSScriptRoot\..\..\strap.ps1" -Raw

        function Extract-Function {
            param($Content, $FunctionName)
            $startIndex = $Content.IndexOf("function $FunctionName")
            if ($startIndex -eq -1) {
                throw "Could not find $FunctionName function in strap.ps1"
            }
            $braceCount = 0
            $inFunction = $false
            $endIndex = $startIndex
            for ($i = $startIndex; $i -lt $Content.Length; $i++) {
                $char = $Content[$i]
                if ($char -eq '{') {
                    $braceCount++
                    $inFunction = $true
                } elseif ($char -eq '}') {
                    $braceCount--
                    if ($inFunction -and $braceCount -eq 0) {
                        $endIndex = $i + 1
                        break
                    }
                }
            }
            return $Content.Substring($startIndex, $endIndex - $startIndex)
        }

        # Extract all needed functions
        $functions = @(
            "Die", "Warn", "Info", "Ok", "Load-Config", "Load-Registry", "Save-Registry",
            "Has-Command", "Ensure-Command",
            "Test-ChinvexAvailable", "Test-ChinvexEnabled", "Invoke-Chinvex", "Invoke-ChinvexQuery",
            "Detect-RepoScope", "Get-ContextName", "Test-ReservedContextName", "Sync-ChinvexForEntry",
            "Invoke-Adopt"
        )
        foreach ($funcName in $functions) {
            try {
                $funcCode = Extract-Function $strapContent $funcName
                Invoke-Expression $funcCode
            } catch {
                Write-Warning "Could not extract $funcName"
            }
        }

        # Setup test environment
        $script:testStrapRoot = Join-Path $TestDrive "straproot"
        $script:testSoftwareRoot = Join-Path $TestDrive "software"
        $script:testToolsRoot = Join-Path $TestDrive "tools"
        $script:testRegistryPath = Join-Path $script:testStrapRoot "registry-v2.json"

        New-Item -ItemType Directory -Path $script:testStrapRoot -Force | Out-Null
        New-Item -ItemType Directory -Path $script:testSoftwareRoot -Force | Out-Null
        New-Item -ItemType Directory -Path $script:testToolsRoot -Force | Out-Null
    }

    BeforeEach {
        # Reset config
        @{
            registry = $script:testRegistryPath
            roots = @{
                software = $script:testSoftwareRoot
                tools = $script:testToolsRoot
                shims = Join-Path $script:testToolsRoot "shims"
            }
            chinvex_integration = $true
            software_root = $script:testSoftwareRoot
            tools_root = $script:testToolsRoot
        } | ConvertTo-Json -Depth 10 | Set-Content (Join-Path $script:testStrapRoot "config.json")

        # Reset registry
        @{
            version = 2
            updated_at = (Get-Date).ToUniversalTime().ToString("o")
            entries = @()
        } | ConvertTo-Json -Depth 10 | Set-Content $script:testRegistryPath

        # Reset chinvex cache
        $script:chinvexChecked = $false
        $script:chinvexAvailable = $false
    }

    function Create-TestRepo {
        param([string]$Path)
        New-Item -ItemType Directory -Path $Path -Force | Out-Null
        New-Item -ItemType Directory -Path (Join-Path $Path ".git") -Force | Out-Null
    }

    Describe "Auto-detect scope from path" {
        It "should auto-detect 'software' scope for repo under software_root" {
            $repoPath = Join-Path $script:testSoftwareRoot "autosoftware"
            Create-TestRepo $repoPath

            Mock Get-Command { return @{ Name = "chinvex" } } -ParameterFilter { $Name -eq "chinvex" }
            Mock Invoke-Chinvex { return $true }
            Mock git { $global:LASTEXITCODE = 0 }

            Invoke-Adopt -TargetPath $repoPath -NonInteractive -StrapRootPath $script:testStrapRoot

            $registry = Get-Content $script:testRegistryPath -Raw | ConvertFrom-Json
            $entry = $registry.entries | Where-Object { $_.name -eq "autosoftware" }
            $entry.scope | Should -Be "software"
        }

        It "should auto-detect 'tool' scope for repo under tools_root" {
            $repoPath = Join-Path $script:testToolsRoot "autotool"
            Create-TestRepo $repoPath

            Mock Get-Command { return @{ Name = "chinvex" } } -ParameterFilter { $Name -eq "chinvex" }
            Mock Invoke-Chinvex { return $true }
            Mock git { $global:LASTEXITCODE = 0 }

            Invoke-Adopt -TargetPath $repoPath -NonInteractive -StrapRootPath $script:testStrapRoot

            $registry = Get-Content $script:testRegistryPath -Raw | ConvertFrom-Json
            $entry = $registry.entries | Where-Object { $_.name -eq "autotool" }
            $entry.scope | Should -Be "tool"
        }
    }

    Describe "Explicit scope override" {
        It "should use 'tool' scope when --tool flag provided" {
            $repoPath = Join-Path $script:testSoftwareRoot "forcedtool"
            Create-TestRepo $repoPath

            Mock Get-Command { return @{ Name = "chinvex" } } -ParameterFilter { $Name -eq "chinvex" }
            Mock Invoke-Chinvex { return $true }
            Mock git { $global:LASTEXITCODE = 0 }

            Invoke-Adopt -TargetPath $repoPath -ForceTool -NonInteractive -StrapRootPath $script:testStrapRoot

            $registry = Get-Content $script:testRegistryPath -Raw | ConvertFrom-Json
            $entry = $registry.entries | Where-Object { $_.name -eq "forcedtool" }
            $entry.scope | Should -Be "tool"
        }

        It "should use 'software' scope when --software flag provided" {
            $repoPath = Join-Path $script:testToolsRoot "forcedsoftware"
            Create-TestRepo $repoPath

            Mock Get-Command { return @{ Name = "chinvex" } } -ParameterFilter { $Name -eq "chinvex" }
            Mock Invoke-Chinvex { return $true }
            Mock git { $global:LASTEXITCODE = 0 }

            Invoke-Adopt -TargetPath $repoPath -ForceSoftware -NonInteractive -StrapRootPath $script:testStrapRoot

            $registry = Get-Content $script:testRegistryPath -Raw | ConvertFrom-Json
            $entry = $registry.entries | Where-Object { $_.name -eq "forcedsoftware" }
            $entry.scope | Should -Be "software"
        }
    }

    Describe "Chinvex context field" {
        It "should set chinvex_context to repo name for software scope" {
            $repoPath = Join-Path $script:testSoftwareRoot "softwarectx"
            Create-TestRepo $repoPath

            Mock Get-Command { return @{ Name = "chinvex" } } -ParameterFilter { $Name -eq "chinvex" }
            Mock Invoke-Chinvex { return $true }
            Mock git { $global:LASTEXITCODE = 0 }

            Invoke-Adopt -TargetPath $repoPath -NonInteractive -StrapRootPath $script:testStrapRoot

            $registry = Get-Content $script:testRegistryPath -Raw | ConvertFrom-Json
            $entry = $registry.entries | Where-Object { $_.name -eq "softwarectx" }
            $entry.chinvex_context | Should -Be "softwarectx"
        }

        It "should set chinvex_context to 'tools' for tool scope" {
            $repoPath = Join-Path $script:testToolsRoot "toolctx"
            Create-TestRepo $repoPath

            Mock Get-Command { return @{ Name = "chinvex" } } -ParameterFilter { $Name -eq "chinvex" }
            Mock Invoke-Chinvex { return $true }
            Mock git { $global:LASTEXITCODE = 0 }

            Invoke-Adopt -TargetPath $repoPath -NonInteractive -StrapRootPath $script:testStrapRoot

            $registry = Get-Content $script:testRegistryPath -Raw | ConvertFrom-Json
            $entry = $registry.entries | Where-Object { $_.name -eq "toolctx" }
            $entry.chinvex_context | Should -Be "tools"
        }

        It "should set chinvex_context to null when --no-chinvex flag used" {
            $repoPath = Join-Path $script:testSoftwareRoot "nochxadopt"
            Create-TestRepo $repoPath

            Mock git { $global:LASTEXITCODE = 0 }

            Invoke-Adopt -TargetPath $repoPath -NoChinvex -NonInteractive -StrapRootPath $script:testStrapRoot

            $registry = Get-Content $script:testRegistryPath -Raw | ConvertFrom-Json
            $entry = $registry.entries | Where-Object { $_.name -eq "nochxadopt" }
            $entry.chinvex_context | Should -Be $null
        }

        It "should set chinvex_context to null when chinvex unavailable" {
            $repoPath = Join-Path $script:testSoftwareRoot "unavailchx"
            Create-TestRepo $repoPath

            Mock Get-Command { return $null } -ParameterFilter { $Name -eq "chinvex" }
            Mock git { $global:LASTEXITCODE = 0 }

            Invoke-Adopt -TargetPath $repoPath -NonInteractive -StrapRootPath $script:testStrapRoot

            $registry = Get-Content $script:testRegistryPath -Raw | ConvertFrom-Json
            $entry = $registry.entries | Where-Object { $_.name -eq "unavailchx" }
            $entry.chinvex_context | Should -Be $null
        }
    }

    Describe "Reserved name validation" {
        It "should reject 'tools' as software repo name" {
            $repoPath = Join-Path $script:testSoftwareRoot "tools"
            Create-TestRepo $repoPath

            Mock git { $global:LASTEXITCODE = 0 }

            { Invoke-Adopt -TargetPath $repoPath -NonInteractive -StrapRootPath $script:testStrapRoot } |
                Should -Throw "*reserved*"
        }

        It "should reject 'archive' as software repo name" {
            $repoPath = Join-Path $script:testSoftwareRoot "archive"
            Create-TestRepo $repoPath

            Mock git { $global:LASTEXITCODE = 0 }

            { Invoke-Adopt -TargetPath $repoPath -NonInteractive -StrapRootPath $script:testStrapRoot } |
                Should -Throw "*reserved*"
        }

        It "should allow adopting repo named 'tools' as tool scope" {
            $repoPath = Join-Path $script:testToolsRoot "tools"
            Create-TestRepo $repoPath

            Mock Get-Command { return @{ Name = "chinvex" } } -ParameterFilter { $Name -eq "chinvex" }
            Mock Invoke-Chinvex { return $true }
            Mock git { $global:LASTEXITCODE = 0 }

            { Invoke-Adopt -TargetPath $repoPath -ForceTool -NonInteractive -StrapRootPath $script:testStrapRoot } |
                Should -Not -Throw
        }
    }
}
```

**Step 2: Run test to verify it fails**
Run: `Invoke-Pester -Path tests/powershell/ChinvexAdopt.Tests.ps1 -TagFilter "Task5"`
Expected: FAIL - tests will fail because Invoke-Adopt doesn't have chinvex integration yet

**Step 3: Write minimal implementation**
```powershell
# Modify Invoke-Adopt function in strap.ps1

function Invoke-Adopt {
  param(
    [string] $TargetPath,
    [string] $CustomName,
    [switch] $ForceTool,
    [switch] $ForceSoftware,
    [switch] $NoChinvex,
    [switch] $NonInteractive,
    [switch] $DryRunMode,
    [string] $StrapRootPath
  )

  # Load config and registry
  $config = Load-Config $StrapRootPath
  $registry = Load-Registry $config

  # Determine target path
  if (-not $TargetPath) {
    $TargetPath = Get-Location
  }

  # Resolve to absolute path
  $resolvedPath = [System.IO.Path]::GetFullPath($TargetPath)

  # Validate within managed roots
  $softwareRoot = $config.roots.software
  $toolsRoot = $config.roots.tools

  $withinSoftware = $resolvedPath.StartsWith($softwareRoot, [StringComparison]::OrdinalIgnoreCase)
  $withinTools = $resolvedPath.StartsWith($toolsRoot, [StringComparison]::OrdinalIgnoreCase)

  if (-not ($withinSoftware -or $withinTools)) {
    Die "Path is not within managed roots: $resolvedPath"
  }

  # Validate it's a git repo
  $gitDir = Join-Path $resolvedPath ".git"
  if (-not (Test-Path $gitDir)) {
    # Try git command
    try {
      & git -C $resolvedPath rev-parse --is-inside-work-tree 2>&1 | Out-Null
      if ($LASTEXITCODE -ne 0) {
        Die "Not a git repository: $resolvedPath"
      }
    } catch {
      Die "Not a git repository: $resolvedPath"
    }
  }

  # Determine name
  $name = if ($CustomName) { $CustomName } else { Split-Path $resolvedPath -Leaf }

  # Check for duplicates
  $existing = $registry | Where-Object { $_.name -eq $name }
  if ($existing) {
    Die "Entry with name '$name' already exists in registry at $($existing.path)"
  }

  # Determine scope (explicit flag > auto-detect from path)
  $scope = if ($ForceTool) {
    "tool"
  } elseif ($ForceSoftware) {
    "software"
  } else {
    # Auto-detect from path
    $detectedScope = Detect-RepoScope -Path $resolvedPath -StrapRootPath $StrapRootPath
    if ($null -eq $detectedScope) {
      Warn "Path is outside managed roots. Defaulting to 'software'. Use --tool or --software to override."
      "software"
    } else {
      Info "Auto-detected scope: $detectedScope (from path)"
      $detectedScope
    }
  }

  # Reserved name check (before any filesystem changes)
  if (Test-ReservedContextName -Name $name -Scope $scope) {
    Die "Cannot use reserved name '$name' for software repos. Reserved names: tools, archive"
  }

  # Extract git metadata (best-effort)
  $url = $null
  $lastHead = $null
  $defaultBranch = $null

  try {
    $remoteUrl = & git -C $resolvedPath remote get-url origin 2>&1
    if ($LASTEXITCODE -eq 0) {
      $url = $remoteUrl.Trim()
    }
  } catch {}

  try {
    $head = & git -C $resolvedPath rev-parse HEAD 2>&1
    if ($LASTEXITCODE -eq 0) {
      $lastHead = $head.Trim()
    }
  } catch {}

  try {
    $branch = & git -C $resolvedPath symbolic-ref --short refs/remotes/origin/HEAD 2>&1
    if ($LASTEXITCODE -eq 0) {
      $defaultBranch = $branch.Trim() -replace '^origin/', ''
    }
  } catch {}

  # Detect stack (best-effort)
  $stackDetected = $null
  Push-Location $resolvedPath
  try {
    if (Test-Path "pyproject.toml") { $stackDetected = "python" }
    elseif (Test-Path "requirements.txt") { $stackDetected = "python" }
    elseif (Test-Path "package.json") { $stackDetected = "node" }
    elseif (Test-Path "go.mod") { $stackDetected = "go" }
    elseif (Test-Path "Cargo.toml") { $stackDetected = "rust" }
  } finally {
    Pop-Location
  }

  # Dry run: show what would happen
  if ($DryRunMode) {
    Info "[DRY RUN] Would adopt: $resolvedPath"
    Info "[DRY RUN] Name: $name"
    Info "[DRY RUN] Scope: $scope"
    Info "[DRY RUN] URL: $url"
    Info "[DRY RUN] Stack: $stackDetected"
    return
  }

  # Create entry
  $timestamp = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
  $entry = [PSCustomObject]@{
    id              = $name
    name            = $name
    url             = $url
    path            = $resolvedPath
    scope           = $scope
    chinvex_context = $null  # Default, updated below if sync succeeds
    shims           = @()
    stack           = if ($stackDetected) { @($stackDetected) } else { @() }
    last_head       = $lastHead
    default_branch  = $defaultBranch
    created_at      = $timestamp
    updated_at      = $timestamp
  }

  # Add to registry
  $newRegistry = @()
  foreach ($item in $registry) {
    $newRegistry += $item
  }
  $newRegistry += $entry
  Save-Registry $config $newRegistry

  # Chinvex sync (after registry write)
  if (Test-ChinvexEnabled -NoChinvex:$NoChinvex -StrapRootPath $StrapRootPath) {
    $contextName = Sync-ChinvexForEntry -Scope $scope -Name $name -RepoPath $resolvedPath
    if ($contextName) {
      # Update entry with successful chinvex context
      $entry.chinvex_context = $contextName
      # Re-save registry with updated chinvex_context
      $updatedRegistry = @()
      foreach ($item in $newRegistry) {
        if ($item.name -eq $name) {
          $item.chinvex_context = $contextName
        }
        $updatedRegistry += $item
      }
      Save-Registry $config $updatedRegistry
    }
  }

  Ok "Adopted: $name ($resolvedPath)"
  Info "Scope: $scope"
  if ($url) { Info "Remote: $url" }
  if ($stackDetected) { Info "Stack: $stackDetected" }
}
```

**Step 4: Run test to verify it passes**
Run: `Invoke-Pester -Path tests/powershell/ChinvexAdopt.Tests.ps1 -TagFilter "Task5"`
Expected: PASS

**Step 5: Commit**
```bash
git add strap.ps1 tests/powershell/ChinvexAdopt.Tests.ps1
git commit -m "feat(chinvex): Task 5 - integrate chinvex with Invoke-Adopt"
```

---

## Batch 2: Commands Part 1 (Tasks 6-10)

